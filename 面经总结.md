### go的调度

```
go语言调度器主要基于三个基本对象：G、M、P：  
1. G代表一个goroutine对象，每次go调用时，都会创建一个G对象  
2. M代表一个线程，每次创建一个M时，都会有一个底层线程创建，所有的G任务最终还是在M上执行  
3. P代表一个处理器，每一个运行的M都会绑定一个P，就像线程必须在一个CPU核上运行  
  
  P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改； 
  M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（最大10000）；
  每一个P保存着本地G任务队列，也有一个全局G任务队列；
  全局G队列会和本地的G任务队列按照一定的策略进行交换，如果本满了则把本地队列的一半送给全局队列；
  P是用一个全局数组来保存的，并且维护着一个全局的P的空闲链表

每次调用go的时候会（抢占式调度）：
1. 创建一个G对象，加入到本地队列或者全局队列中
2. 如果还有空闲的P，则创建一个M
   2.1 先找到一个空闲的P，如果没有则返回
   2.2 调用系统api创建线程，windows就是createThread
3. M会启动一个底层线程，循环执行能找到的G任务
4. G任务执行顺序为先从本地队列获取，再去全局队列获取

启动的时候会创建一个线程sysmon，用于监控和管理，内部是一个循环：
1. 记录所有P的G任务计数schedtick（执行每一个G任务后递增）
2. 如果检测到每一个P的schedtick一直没有递增，说明一直在执行同一个任务，超过一定时间（10ms）后，在G任务的栈信息中添加一个标记
3. 添加标记的G在执行时，如果遇到非内联函数调用就会检查标记，然后中断自己，添加到队列末尾，随后P去执行下一个G任务
4. 如果没有遇到非内联函数调用，则会一直执行直到结束

关于G任务的中断：
1. 中断时会先将寄存器中的栈信息保存到自己的G对象中
2. 再次轮到执行时，将保存的栈信息复制到寄存器中继续执行

main函数其实就是作为一个goroutine来执行的

P find runnable G：调度时，首先会以1/61的概率从全局队列中获取G(避免饥饿)，如果没有则从本地任务队列获取G，
                   本地任务队列获取不到就去全局队列获取（因为前面仅仅是1/61的概率），
                   如果还没有拿到，就执行netpoll，检查是否有io就绪的G，如果还是没有，那么就只好从别的队列偷取
                   
```

![](https://img-blog.csdn.net/20160926143021847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

[原文链接](https://blog.csdn.net/liangzhiyang/article/details/52669851)



### 协程goroutine

* 和线程都可以实现程序的并发执行
* 通过channel来进行协程间的通信
* 只需要在函数调用前添加go关键字就可以实现协程，创建并发任务
* 关键字go并非执行并发任务，而是创建一个并发任务单元
* 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈
* 当启动多个goroutine时，如果其中一个goroutine异常了，并且我们并没有对进行异常处理，那么整个程序都会终止，所以我们在编写程序时候最好每个goroutine所运行的函数都做异常处理，异常处理采用recover
* goroutine本质上是协程，可以理解为不受内核调度，而受go调度器管理的线程
* goroutine之间可以通过channel进行通信或者说是数据共享，也可以使用全局变量来进行数据共享



### 协程、线程、进程的区别

* 进程是系统进行资源分配的单位，每个进程都有独立的内存空间，进程间的切换开销较大
* 线程是cpu调度的基本单位，自己不拥有资源，但共享同一个进程的全部资源，切换开销较小
* 协程是一种用户态的轻量级线程，调度完全有用户控制。拥有自己的寄存器上下文和栈，切换速度很快



### 主协程如何等其他协程结束操作

使用channel进行通信，例如context、select等

还有无限等待、计时等待、等待组等



### go的GC过程

[原文链接](https://blog.csdn.net/weixin_39998006/article/details/100928939)

GC的优点：

* 可以将未被任何对象引用的对象进行回收，避免悬挂指针
* 只有回收器可以释放对象，不会出现二次释放
* 回收器掌握堆中对象的全局信息以及可能访问堆中对象的线程信息，可以决定任意对象是否需要回收
* 回收器管理对象，模块之间减少耦合

Go的GC：

* 基于Mark Sweep，不过是并发的Mark和并发的Sweep，即并发GC（两层含义）

  * 每个mark或sweep本身是多个线程(协程)执行的——concurrent

    * GC时整体进行STW，对象引用关系不再改变，对mark或sweep进行分块，就能多个线程(协程)执行任务mark或sweep

  * mutator(应用程序)和collector(收集器)同时运行——background

    * 实现相对复杂，因为mutator会改变已经被scan对象的引用关系，示例：

      ```go
      b.obj1=c
       
                              gc mark start
       
                              gc scan a
       
      mutaotr  a.obj1=c
       
      mutator  b.obj1=nil
       
                              gc scan b
       
                              gc mark termination
       
                              sweep and free c(error)
      b有c的引用. gc开始, 先扫描了a, 然后mutator运行, a引用了c, b不再引用c, gc再扫描b, 
      然后sweep, 清除了c. 这里其实a还引用了c, 导致了正确性问题.
      ```

    * 引入写屏障，是在写入指针前执行的一小段代码用于防止指针丢失. 这一小段代码Golang是在编译时写入的. Golang目前写屏障在mark阶段开启

    * 将c的指针写入到a.obj1之前, 会先执行一段判断代码, 如果c已经被扫描过, 就不再扫描, 如果c没有被扫描过, 就把c加入到待扫描的队列中. 这样就不会出现丢失存活对象的问题存在

  * 三色标记法：并发的GC算法，原理：

    ```
    1. 首先创建三个集合：白, 灰, 黑. 白色节点表示未被mark和scan的对象, 灰色节点表示已经被mark, 但是还没有scan的对象, 而黑色表示已经mark和scan完的对象.
    2. 初始时所有对象都在白色集合.
    3. 从根节点开始广度遍历, 将其引用的对象加入灰色集合.
    4. 遍历灰色集合, 将灰色对象引用的白色对象放入灰色集合, 之后将此灰色对象放入黑色集合.
    
    在Go Runtime的实现中, 并没有白色集合, 灰色集合, 黑色集合这样的容器：
    白色对象: 某个对象对应的gcMarkBit为0(未被标记)
    灰色对象: gcMarkBit为1(已被标记)且在(待scan)gcWork的待scan buffer中
    黑色对象: gcMarkBit为1(已被标记)且不在(已经scan)gcWork的待scan buffer中
    
    分代GC：GC后的gcMarkBits不清空, 对象存活为1. 那下一次GC时, 在还没有进行标记时, 发现gcMarkBits为1, 那就是老对象, 为0, 就是新分配的对象
    ```

    ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NzgzNTY1LWI3MjgyY2UzZDM4NzJiOGYuZ2lmP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNDMwL2Zvcm1hdC93ZWJw)



### channel如何实现

channel是一个结构体，其中有三部分主要内容：

1.指向内容的环形缓存区，及其相关游标	2.读取和写入的排队goroutine链表	3.锁

写满或者读空时，就将当前goroutine加入到recvq或者sendq中，并让出CPU

```go
type hchan struct {
   qcount   uint           // total data in the queue	当前队列中剩余元素个数
   dataqsiz uint           // size of the circular queue	环形队列长度，即缓冲区的大小
   buf      unsafe.Pointer // points to an array of dataqsiz elements	环形队列指针
   elemsize uint16	//每个元素的大小
   closed   uint32	//表示当前通道是否处于关闭状态
   elemtype *_type // element type	元素类型，用于数据传递过程中的赋值
   sendx    uint   // send index	uint是环形缓冲区的状态字段，它指示缓冲区的当前索引 - 支持数组，它可以从中发送数据和接收数据
   recvx    uint   // receive index	
   recvq    waitq  // list of recv waiters	等待读消息的goroutine队列
   sendq    waitq  // list of send waiters	等待写消息的goroutine队列

   // lock protects all fields in hchan, as well as several
   // fields in sudogs blocked on this channel.
   //
   // Do not change another G's status while holding this lock
   // (in particular, do not ready a G), as this can deadlock
   // with stack shrinking.
   lock mutex	//互斥锁，为每个读写操作锁定通道，因为发送和接收必须是互斥操作
}
```

带缓冲的channel：

![](https://raw.githubusercontent.com/guyan0319/golang_development_notes/master/images/9.9.3.png)

写入数据：

发送操作概要

```
锁定整个通道结构。
确定写入。尝试recvq从等待队列中等待goroutine，然后将元素直接写入goroutine。
如果recvq为Empty，则确定缓冲区是否可用。如果可用，从当前goroutine复制数据到缓冲区。
如果缓冲区已满，则要写入的元素将保存在当前正在执行的goroutine的结构中，并且当前goroutine将在sendq中排队并从运行时挂起。
写入完成释放锁。
```

![image-20210929105531339](C:\Users\liuhq32054\AppData\Roaming\Typora\typora-user-images\image-20210929105531339.png)

[原文链接](https://blog.csdn.net/guyan0319/article/details/90201405)



### 内联函数

```
  内联就是把简短的函数放在调用的地方展开，消除了函数调用本身的开销，并可以使得编译器更高效的执行优化策略
```



### go struct 能不能比较

```
1.如果结构体中的所有成员都是可以比较的，那么结构体就可以比较
2.如果结构体中存在不可以比较的成员，那么结构体不可以比较
3.结构体的转换需要他们具备完全相同的成员
4.切片和map不可以比较
5.指针类型可以比较，比较的就是指针所指向的内存地址
6.struct可以在可以比较的情况下作为map的键key
```



### go中的defer

* Golang的defer就是延迟调用:defer会在当前函数返回之前执行defer注册的函数(在return之后进行调用)
* 比如defer func_x( )这样语句会让你注册一个函数变量到defer的全局链表中，在defer语句所在的函数退出之前调用
* 一个函数有多个defer时，压栈执行，先进后出
* defer会和函数绑定，作用域只是当前绑定的函数内
* panic的情况下也能执行，因为发生了 panic 却不代表进程一定会挂掉
* recover只有在defer中使用才更有意义，如果在其他地方使用，由于已经调用结束而提前返回而无法有效捕捉错误
* 一个被defer的函数的参数已经计算好，后续的改变不会影响defer的值

```
type _defer struct {
    sp      uintptr   //函数栈指针
    pc      uintptr   //程序计数器
    fn      *funcval  //函数地址
    link    *_defer   //指向自身结构的指针，用于链接多个defer
}

  新声明的defer总是添加到链表头部，函数返回前执行defer则是从链表首部依次取出执行
```



### go select

```
select+case是用来监听阻塞goroutine的，如果只有一个select{}没有case则监听当前程序中的goroutine，需要有真实的goroutine，否则会报panic
select底下有多个可执行的case，则随机执行一个
select常配合for循环来监听channel。需要注意的是在这个场景下，break只是退出当前select而不会退出for，需要用break TIP / goto的方式
无缓冲的通道会有传值会立刻close，并在close之前阻塞，有缓冲的通道则即使close了也会继续让接收后面的值
同个通道多个goroutine进行关闭，可用recover panic的方式来判断通道关闭问题
select执行过程可以类比成一个函数，函数输入case数组，输出选中的case，然后程序流程转到选中的case块
select语句中读操作要判断是否成功读取，关闭的channel也可以读取
select语句中除default外，每个case只能操作一个channel，要么读要么写
select用来处理异步IO问题，最大的限制就是每个case语句都必须是一个IO操作
```

![](https://img-blog.csdn.net/20180831011529435?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5NTc3NTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

[源码详解](https://blog.csdn.net/xzw12138/article/details/108104603?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control)



### go context包的用途

```
  控制并发有两种经典的方式，一种是 WaitGroup，另外一种就是 Context
  WaitGroup 是一种控制并发的方式，它的这种方式是控制多个 goroutine 同时完成，这样可以防止泄露，多用于多个goroutine协作完成一个任务
  想结束一个goroutine也可以采取select + case的方式，但是当goroutine很多并且有很多衍生的时候并不靠谱：
  func main() {
	stop := make(chan bool)

	go func() {
		for {
			select {
			case <-stop:
				fmt.Println("监控退出，停止了...")
				return
			default:
				fmt.Println("goroutine监控中...")
				time.Sleep(2 * time.Second)
			}
		}
	}()

	time.Sleep(10 * time.Second)
	fmt.Println("可以了，通知监控停止")
	stop <- true
	//为了检测监控过是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}
  例如一个网络请求request，每一个request都要开启一个goroutine来完成业务逻辑，这些goroutine可能会再开启其他的goroutine，我们需要一种
可以跟踪goroutine的方案来控制开关，就是goroutine的上下文context：
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	go func(ctx context.Context) {
		for {
			select {
			case <-ctx.Done():
				fmt.Println("监控退出，停止了...")
				return
			default:
				fmt.Println("goroutine监控中...")
				time.Sleep(2 * time.Second)
			}
		}
	}(ctx)

	time.Sleep(10 * time.Second)
	fmt.Println("可以了，通知监控停止")

	cancel()
	
	//为了检测监控过是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}

context接口定义：
type Context interface {
  //获取截止的时间，第一个参数是截止时间，第二个是表示有没有设置截止时间
	Deadline() (deadline time.Time, ok bool)  

  //返回一个只读的chan，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求
  //通过 Done 方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源
	Done() <-chan struct{}

	Err() error

  //获取该 Context 上绑定的值，是一个键值对
  //要通过一个 Key 才可以获取对应的值，这个值一般是线程安全的
	Value(key interface{}) interface{}
}
通过context中的with函数俩衍生更多的context，基于一个父 Context 创建出子 Context以及cancel

可以通过withvalue来传递数据：
var key string = "name"

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	//附加值
	valueCtx := context.WithValue(ctx, key, "【监控1】")
	go watch(valueCtx)
	time.Sleep(10 * time.Second)
	fmt.Println("可以了，通知监控停止")
	cancel()
	//为了检测监控过是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}

func watch(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
		//取出值
			fmt.Println(ctx.Value(key), "监控退出，停止了...")
			return
		default:
		//取出值
			fmt.Println(ctx.Value(key), "goroutine监控中...")
			time.Sleep(2 * time.Second)
		}
	}
}

使用原则：
1.不要把 Context 放在结构体中，要以参数的方式传递
2.以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。
3.给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO
4.Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递
5.Context 是线程安全的，可以放心的在多个 goroutine 中传递
```

[原文链接](https://zhuanlan.zhihu.com/p/58967892)



### HTTP长连接和短连接

短连接：浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接

管理起来比较简单，存在的连接都是有用的，不需要额外的控制手段

频繁的连接会浪费时间和带宽

长连接：一个网页打开完成后，客户端和服务器间传输数据的tcp连接不关闭

长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间

负载可能承受不住



### client如何实现长连接

1. HTTP client 定义

```go
httpClient := &http.Client{
    //为http.RoundTripper接口，定义功能为负责http的请求分发,还实现了对空闲连接的管理
		Transport: trans,
    //从发起请求到整个报文响应结束的超时时间
		Timeout:   config.Client_Timeout * time.Millisecond,
	}
```

2. DefaultTransport 定义

```go
var DefaultTransport RoundTripper = &Transport{
	Proxy: ProxyFromEnvironment,
	DialContext: (&net.Dialer{
        //连接超时时间
		Timeout:   30 * time.Second,
        //开启长连接
		KeepAlive: 30 * time.Second,
		DualStack: true,
	}).DialContext,
    //最大空闲连接数
	MaxIdleConns:          100,
    //连接最大空闲时间
	IdleConnTimeout:       90 * time.Second,
    //限制TLS握手使用的时间
	TLSHandshakeTimeout:   10 * time.Second,
    //限制客户端在发送一个包含：100-continue的http报文头后，等待收到一个go-ahead响应报文所用的时间
	ExpectContinueTimeout: 1 * time.Second,
}
```

所以长连接的问题关系到KeepAlive参数的使用设置：

​		要想使用keepalive机制，首先得开启SO_KEEPALIVE设置；然后系统会在connection空闲keepalive_time时间后发起探针，连续keepalive_probes个探针失败时，系统将关闭连接。keepalive_intvl为两次探针的间隔时间

​        当获取一个IdleConn处理完request后，会调用tryPutIdleConn方法回放conn

[原文链接](https://blog.csdn.net/kdpujie/article/details/73177179)



### go语言中new和make的区别

new函数是内建函数，定义为：

```go
func new(Type) *Type
```

初始化一个指向类型的指针（*Type），使用new来分配空间，返回值是指针



make也是内建函数，定义为：

```go
func make(t Type, size ...IntegerType) Type
```

为slice、map、chan初始化并返回引用type，仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是T*）的一个初始化的（不是零值）的实例



### go中的引用类型

slice	map	channel	interface



### go的同步锁

* 当一个goroutine获得了Mutex后，其他goroutine只能等待阻塞，除非释放Mutex

* RWMutex在读锁占用情况下会阻止写，不阻止读；在写锁占用情况下，会阻止其他任何协程，由一个独占

  

### 并发编程

并行是指两个或多个事件在同一时刻发生，并发是指两个或多个时间在同一个时间间隔发生

并发偏重于多任务交替执行，是在同一个实体上的多个事件



### slice，len，cap，共享，扩容

append函数，因为slice底层数据结构是，由数组、len、cap组成，所以，在使用append扩容时，会查看数组后面有没有连续内存快，有就在后面添加，没有就重新生成一个大的数组



### 实现set

```go
type inter interface {}
type Set struct {
    m map[inter]bool
    sync.RWMutex
}

func New() *Set{
    return &Set{
        m : map[inter]bool{}
    }
}

func (s *Set) Add(item inter) {
    s.Lock()
    defer s.Unlock()
    s.m[inter] = true
}
```



### slice的底层原理

[原文链接](https://blog.csdn.net/lengyuezuixue/article/details/81197691)

Go的数组是值类型，赋值和函数传参操作都会赋值整个数组的数据

* 切片是对数组一个连续片段的引用，是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。

* ```go
  type slice struct {  
      array unsafe.Pointer
      len   int
      cap   int
  }
  ```

  ![](https://img-blog.csdn.net/20180725103740874?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd5dWV6dWl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  Pointer是指向一个数组的指针，len代表当前切片的长度，cap是容量

  ![](https://img-blog.csdn.net/20180725103816476?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd5dWV6dWl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* 创建切片要用make函数

* nil切片与空切片：区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素

* 扩容策略：

  * 如果新容量大于旧容量的两倍，则直接采用新容量；
  * 如果新容量小于等于旧容量：
    * 如果旧切片的长度小于1024，那么新的容量等于两倍的旧容量
    * 如果旧切片的长度大于等于1024，那么通过for循环每次增加1/4的容量直到大于等于预期容量

* 建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug

* 原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组

* 切片拷贝：copy函数

  * slicecopy ：slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了
  * slicestringcopy：字节数组拷贝

* 如果用range遍历切片，拿到的value是切片中的值拷贝，所以每次打印value的地址都不变，需要通过&slice[index]获取地址



### MySQL优化



### 网络状态码，常用方法



### TCP三次/四次握手



### B+Tree索引树

























































